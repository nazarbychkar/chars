import { NextRequest, NextResponse } from "next/server";
import { sqlGetAllOrders, sqlPostOrder } from "@/lib/sql";
import crypto from "crypto";

// ==========================
// GET /api/orders
// ==========================
export async function GET() {
  try {
    const orders = await sqlGetAllOrders();
    return NextResponse.json(orders);
  } catch (error) {
    console.error("[GET /orders]", error);
    return NextResponse.json(
      { error: "Failed to fetch orders" },
      { status: 500 }
    );
  }
}

// ==========================
// POST /api/orders
// ==========================
export async function POST(req: NextRequest) {
  try {
    console.log("=".repeat(50));
    console.log("[POST /api/orders] Starting order creation...");
    
    const body = await req.json();
    console.log("[POST /api/orders] Received body:", JSON.stringify(body, null, 2));

    const {
      customer_name,
      phone_number,
      email,
      delivery_method,
      city,
      post_office,
      comment,
      payment_type, // "full" або "prepay"
      items,
    } = body;

    console.log("[POST /api/orders] Extracted data:", {
      customer_name,
      phone_number,
      email,
      delivery_method,
      city,
      post_office,
      payment_type,
      itemsCount: items?.length,
    });

    // ✅ Basic validation
    if (
      !customer_name ||
      !phone_number ||
      !delivery_method ||
      !city ||
      !post_office ||
      !items?.length
    ) {
      console.error("[POST /api/orders] Validation failed:", {
        hasCustomerName: !!customer_name,
        hasPhoneNumber: !!phone_number,
        hasDeliveryMethod: !!delivery_method,
        hasCity: !!city,
        hasPostOffice: !!post_office,
        hasItems: !!items?.length,
      });
      return NextResponse.json(
        { error: "Missing required order fields" },
        { status: 400 }
      );
    }
    console.log("[POST /api/orders] Validation passed");

    const fullAmount = items.reduce(
      (total: number, item: { price: number; quantity: number }) =>
        total + item.price * item.quantity,
      0
    );

    const amountToPay = payment_type === "prepay" ? 300 : fullAmount;
    const amountInKopecks = Math.round(amountToPay * 100);
    
    console.log("[POST /api/orders] Amount calculation:", {
      fullAmount,
      amountToPay,
      amountInKopecks,
      payment_type,
    });

    const basketOrder = items.map(
      (item: {
        name: string;
        quantity: number;
        price: number;
        product_id: number;
        size: number;
      }) => ({
        name: item.name,
        qty: item.quantity,
        sum: Math.round(item.price * item.quantity * 100),
        total: Math.round(item.price * item.quantity * 100),
        unit: "шт.",
        code: `${item.product_id}-${item.size}`,
      })
    );

    const reference = crypto.randomUUID();
    console.log("[POST /api/orders] Generated reference:", reference);

    // ✅ Створення інвойсу Monobank

    // NOTE: Monobank webhooks must be able to reach your server from the public internet.
    // If you use "localhost" in webHookUrl, Monobank cannot call it unless you tunnel (e.g. with ngrok).
    // Use your public domain or a tunnel URL for webHookUrl and redirectUrl.

    // For local development, set up a tunnel (e.g. ngrok) and use its URL here:
    // const PUBLIC_URL = process.env.NEXT_PUBLIC_PUBLIC_URL || "http://localhost:3000";
    // Example: "https://abc123.ngrok.app"

    const PUBLIC_URL =
      process.env.NEXT_PUBLIC_PUBLIC_URL || "http://localhost:3000";
    
    console.log("[POST /api/orders] PUBLIC_URL:", PUBLIC_URL);
    console.log("[POST /api/orders] MONO_TOKEN exists:", !!process.env.NEXT_PUBLIC_MONO_TOKEN);

    const invoicePayload = {
      amount: amountInKopecks,
      ccy: 980,
      merchantPaymInfo: {
        reference,
        destination: "Оплата замовлення",
        comment: comment || "Оплата замовлення",
        basketOrder,
      },
      redirectUrl: `${PUBLIC_URL}/final`,
      webHookUrl: `${PUBLIC_URL}/api/mono-webhook`,
      validity: 3600,
      paymentType: "debit",
    };
    
    console.log("[POST /api/orders] Creating invoice with payload:", JSON.stringify(invoicePayload, null, 2));

    const monoRes = await fetch(
      "https://api.monobank.ua/api/merchant/invoice/create",
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "X-Token": process.env.NEXT_PUBLIC_MONO_TOKEN!,
        },
        body: JSON.stringify(invoicePayload),
      }
    );
    
    console.log("[POST /api/orders] Monobank response status:", monoRes.status);
    console.log("[POST /api/orders] Monobank response ok:", monoRes.ok);

    const invoiceData = await monoRes.json();
    console.log("[POST /api/orders] Invoice data response:", JSON.stringify(invoiceData, null, 2));
    
    if (!monoRes.ok) {
      console.error("[POST /api/orders] Monobank error:", invoiceData);
      return NextResponse.json(
        { error: "Не вдалося створити рахунок", details: invoiceData },
        { status: 500 }
      );
    }

    const { invoiceId, pageUrl } = invoiceData;
    
    console.log("[POST /api/orders] Extracted from invoice data:", {
      invoiceId,
      pageUrl,
    });

    // ✅ Зберігання замовлення у БД (статус "pending" - ще не оплачено)
    console.log("[POST /api/orders] Saving order to database...");
    await sqlPostOrder({
      customer_name,
      phone_number,
      email,
      delivery_method,
      city,
      post_office,
      comment,
      payment_type,
      invoice_id: invoiceId,
      payment_status: "pending", // замовлення створено, але ще не оплачено
      items,
    });
    console.log("[POST /api/orders] Order saved to database successfully");

    // ✅ НЕ відправляємо в Telegram поки не оплачено
    // Telegram повідомлення буде відправлено в webhook після успішної оплати
    
    console.log("[POST /api/orders] Returning response with:", {
      invoiceUrl: pageUrl,
      invoiceId: invoiceId,
    });

    console.log("[POST /api/orders] Successfully completed order creation");
    console.log("=".repeat(50));
    
    return NextResponse.json({ invoiceUrl: pageUrl, invoiceId: invoiceId });
  } catch (error) {
    console.error("[POST /api/orders] ERROR occurred:", error);
    console.error("[POST /api/orders] Error details:", {
      message: error instanceof Error ? error.message : "Unknown error",
      stack: error instanceof Error ? error.stack : undefined,
    });
    console.log("=".repeat(50));
    
    return NextResponse.json(
      { error: "Failed to create order", details: error instanceof Error ? error.message : "Unknown error" },
      { status: 500 }
    );
  }
}
